#ifndef FLOWNETWORK_H_
#define FLOWNETWORK_H_

#include <cinttypes>
#include <forward_list>

#include "Arc.h"

namespace flowsolver {

class FlowNetwork {
	uint32_t num_nodes;
	std::vector<int64_t> balances;
	// TODO: better data structures?
	// std::vector<std::vector<Arc *>> might actually be best
	std::vector<std::forward_list<Arc *>> arcs;
public:
	FlowNetwork(uint32_t num_nodes);
	// constant time
	uint32_t getNumNodes() const;
	// constant time
	void addArc(uint32_t src, uint32_t dst, uint64_t capacity, int64_t cost);
	/*
	 * Linear in number of edges in src.
	 * Returns NULL if no such Arc present
	 */
	Arc *getArc(uint32_t src, uint32_t dst);
	std::forward_list<Arc *> &getAdjacencies(uint32_t src);
	int64_t getBalance(uint32_t id) const;
	void setSupply(uint32_t id, int64_t supply);

	int64_t getResidualCapacity(Arc *arc, uint32_t src_id);
	void pushFlow(Arc *arc, uint32_t src_id, uint64_t flow);

	// iterator
	friend class const_noconst_iterator;

	template<bool is_const_iterator = true>
	class const_noconst_iterator : public std::iterator
		  <std::forward_iterator_tag,
		   typename std::conditional<is_const_iterator, const Arc, Arc>::type>
	{
	private:
		typedef typename std::conditional
				<is_const_iterator, const FlowNetwork *, FlowNetwork *>
				::type FlowNetworkType;
		typedef typename std::conditional
				<is_const_iterator, const Arc, Arc>::type ArcType;

		typedef typename std::conditional<is_const_iterator,
				std::vector<std::forward_list<Arc *>>::const_iterator,
				std::vector<std::forward_list<Arc *>>::iterator>::type
				VectorIterator;
		typedef typename std::conditional<is_const_iterator,
						std::forward_list<Arc *>::const_iterator,
						std::forward_list<Arc *>::iterator>::type
						ListIterator;
		typename std::conditional<is_const_iterator, const Arc, Arc> value_type;

		FlowNetworkType g;
		VectorIterator vec_it;
		ListIterator list_it;

	public:
		const_noconst_iterator() : g(0) { }

		const_noconst_iterator(FlowNetworkType g) : g(g) {
			vec_it = g->arcs.begin();
			list_it = vec_it->begin();
		}

		const_noconst_iterator(FlowNetworkType g, bool) : g(g) {
			// for end sentinel
			list_it = g->arcs.end();
		}

		// Copy constructor. Implicit conversion from regular iterator to
		// const_iterator.
		const_noconst_iterator(const const_noconst_iterator<false>& other) :
			g(other.g), vec_it(other.vec_it), list_it(other.list_it) {}

		ArcType &operator*() const {
			return *list_it;
		}

		ArcType *operator->() const {
			return &(*list_it);
		}

		const_noconst_iterator<is_const_iterator> operator++() {
			list_it++;
			// prefix operator
			while (list_it == vec_it->end()) {
				// end of map, go on to next value in vector
				// (may need to do this repeatedly if maps are empty)
				vec_it++;
				if (vec_it == g->arcs.end()) {
					// no elements left to iterate over: end
					break;
				}
				list_it = vec_it->begin();
			}
			return *this;
		}

		const_noconst_iterator<is_const_iterator> operator++(int) {
			// postfix operator
			const_noconst_iterator<is_const_iterator> old(*this);
			++(*this);
			return old;
		}

		bool operator==(const const_noconst_iterator<is_const_iterator>& it)
				const {
			if (vec_it == it.vec_it) {
				if (vec_it == g->arcs.end()) {
					// End iterator not unique.
					// The end sentinel has map_it set to default value.
					// By contrast, the end iterator reached by successive
					// applications of the ++ operator has map_it set to the
					// last legal value.
					return true;
				} else {
					return list_it == it.list_it;
				}
			} else {
				return false;
			}
		}

		bool operator!=(const const_noconst_iterator<is_const_iterator>& it)
				const {
			return !(*this == it);
		}

		// TODO: This should be automatically generated by compiler,
		// unclear why it's not
		const_noconst_iterator<is_const_iterator> &operator=(
				const const_noconst_iterator<is_const_iterator>& other) {
			g = other.g;
			list_it = other.list_it;
			vec_it = other.vec_it;

			return *this;
		}

		friend class const_noconst_iterator<true>;
	};

	typedef const_noconst_iterator<false> iterator;
	typedef const_noconst_iterator<true> const_iterator;

	iterator begin() { return iterator(this); }
	const_iterator begin() const { return const_iterator(this); }
	iterator end() { return iterator(this, true); }
	const_iterator end() const { return const_iterator(this, true); }

	virtual ~FlowNetwork();
};

} /* namespace flowsolver */

#endif /* FLOWNETWORK_H_ */
