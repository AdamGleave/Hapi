/* -*- mode: C++; indent-tabs-mode: nil; -*-
 *
 * This is derived from dimacs-solver in LEMON.
 *
 * Copyright (C) 2003-2013
 * Egervary Jeno Kombinatorikus Optimalizalasi Kutatocsoport
 * (Egervary Research Group on Combinatorial Optimization, EGRES).
 *
 * Copyright (C) 2015
 * Adam Gleave
 *
 *
 * ===========================================================================
 * Boost Software License, Version 1.0
 * ===========================================================================
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Permission to use, modify and distribute this software is granted
 * provided that this copyright notice appears in all copies. For
 * precise terms see the accompanying LICENSE file.
 *
 * This software is provided "AS IS" with no warranty of any kind,
 * express or implied, and with no claim as to its suitability for any
 * purpose.
 *
 */

///\ingroup tools
///\file
///\brief DIMACS problem solver from LEMON.
///
/// See
/// \code
///   dimacs-solver --help
/// \endcode
/// for more info on usage.

#include <iostream>
#include <fstream>
#include <cstring>

#include <lemon/smart_graph.h>
#include <lemon/lgf_writer.h>
#include <lemon/time_measure.h>

#include <lemon/error.h>

#include <lemon/dijkstra.h>
#include <lemon/preflow.h>
#include <lemon/matching.h>
#include <lemon/cycle_canceling.h>
#include <lemon/capacity_scaling.h>
#include <lemon/cost_scaling.h>
#include <lemon/network_simplex.h>

#include "lemon_min_cost.h"

LemonMinCost::LemonMinCost(int argc, const char *argv[]) : ap(argc, argv),
																							 is(&std::cin), os(&std::cout) { }

void LemonMinCost::openFiles() {
	std::ifstream input;
	std::ofstream output;

	switch(ap.files().size()) {
	case 2:
		output.open(ap.files()[1].c_str());
		if (!output) {
			throw lemon::IoError("Cannot open the file for writing", ap.files()[1]);
		}
		os = &output;
	case 1:
		input.open(ap.files()[0].c_str());
		if (!input) {
			throw lemon::IoError("File cannot be found", ap.files()[0]);
		}
		is = &input;
	case 0:
		break;
	default:
		std::cerr << ap.commandName() << ": too many arguments\n";
		exit(1);
	}
}

void LemonMinCost::run() {
	ap.other("[INFILE [OUTFILE]]",
					 "If either the INFILE or OUTFILE file is missing the standard\n"
					 "     input/output will be used instead.")
		.boolOption("q", "Do not print any report")
		.boolOption("int","Use 'int' for capacities, costs etc. (default)")
		.optionGroup("datatype","int")
#ifdef LEMON_HAVE_LONG_LONG
		.boolOption("long","Use 'long long' for capacities, costs etc.")
		.optionGroup("datatype","long")
#endif
		.boolOption("double","Use 'double' for capacities, costs etc.")
		.optionGroup("datatype","double")
		.boolOption("ldouble","Use 'long double' for capacities, costs etc.")
		.optionGroup("datatype","ldouble")
		.onlyOneGroup("datatype")
		.stringOption("infcap","Value used for 'very high' capacities","0")
		// declare options for solver algorithm
		.boolOption("scc","Simple cycle-cancelling")
		.optionGroup("solver","scc")
		.boolOption("mmcc","Minimum-mean cycle-cancelling")
		.optionGroup("solver","mmcc")
		.boolOption("cat","Cancel-and-tighten")
		.optionGroup("solver","cat")
		.boolOption("ssp","Successive shortest path")
		.optionGroup("solver","ssp")
		.boolOption("cas","Capacity scaling")
		.optionGroup("solver","cas")
		.boolOption("cos","Cost scaling")
		.optionGroup("solver","cos")
		.boolOption("ns","Network simplex")
		.optionGroup("solver","ns")
		// make it a required option
		.mandatoryGroup("solver")
		// only one of the options can be picked
		.onlyOneGroup("solver")
		.run();

	report = ap.given("q");

	desc = lemon::dimacsType(*is);

	if (desc.type != lemon::DimacsDescriptor::MIN) {
		std::cerr << "Unsupported problem type " << desc.type;
		exit(1);
	}

	if(report) {
		std::cout << "\nNum of nodes: " << desc.nodeNum;
		std::cout << "\nNum of arcs:  " << desc.edgeNum;
		std::cout << "\n\n";
	}

	if(ap.given("double")) {
		MinCostSolver<double, double> mcs(*this);
		mcs.run();
	}	else if(ap.given("ldouble")) {
		MinCostSolver<long double, long double> mcs(*this);
		mcs.run();
	}
#ifdef LEMON_HAVE_LONG_LONG
	else if(ap.given("long")) {
		MinCostSolver<long long, long long> mcs(*this);
		mcs.run();
	}
	else {
		MinCostSolver<int, long long> mcs(*this);
		mcs.run();
	}
#else
	else {
		MinCostSolver<int, long>mcs(*this);
		mcs.run();
	}
#endif
}

template<class Value, class LargeValue>
MinCostSolver<Value,LargeValue>::MinCostSolver(LemonMinCost &lmc) : lmc(lmc),
	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	 	          lower(g), cap(g), cost(g), sup(g) {}

template<class Value, class LargeValue> template<class MCF>
void MinCostSolver<Value,LargeValue>::solveGeneric
												(std::function<typename MCF::ProblemType(MCF &)> &run) {
	MCF algo(g);
	algo.lowerMap(lower).upperMap(cap).costMap(cost).supplyMap(sup);
	typename MCF::ProblemType res = run(algo);
	if (lmc.report) {
		std::cerr << "Feasible flow: "
				      << (res == MCF::OPTIMAL ? "found" : "not found") << std::endl;
		if (res)
			std::cerr << "Min flow cost: " << algo.template totalCost<LargeValue>()
					      << std::endl;
	}
}

template<class Value, class LargeValue>
void MinCostSolver<Value,LargeValue>::run() {
	std::stringstream iss(static_cast<std::string>(lmc.ap["infcap"]));
	iss >> infty;
	if(iss.fail()) {
		std::cerr << "Cannot interpret '"
							<< static_cast<std::string>(lmc.ap["infcap"]) << "' as infinite"
							<< std::endl;
		exit(1);
	}

	lemon::Timer ti;

	ti.restart();
	lemon::readDimacsMin(*lmc.is, g, lower, cap, cost, sup, infty, lmc.desc);
	ti.stop();
	std::cerr << "FILETIME: " << ti << std::endl;

	ti.restart();

	if (lmc.ap.given("scc")) {
		typedef lemon::CycleCanceling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType
						 { return algo.run(MCF::Method::SIMPLE_CYCLE_CANCELING); };
		solveGeneric<MCF>(fn);
	} else if (lmc.ap.given("mmcc")) {
		typedef lemon::CycleCanceling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType
						 { return algo.run(MCF::Method::MINIMUM_MEAN_CYCLE_CANCELING); };
		solveGeneric<MCF>(fn);
	}	else if (lmc.ap.given("cat")) {
		typedef lemon::CycleCanceling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType
						 { return algo.run(MCF::Method::CANCEL_AND_TIGHTEN); };
		solveGeneric<MCF>(fn);
	} else if (lmc.ap.given("ssp")) {
		typedef lemon::CapacityScaling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType { return algo.run(1); };
		solveGeneric<MCF>(fn);
	} else if (lmc.ap.given("cas")) {
		typedef lemon::CapacityScaling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType { return algo.run(); };
		solveGeneric<MCF>(fn);
	} else if (lmc.ap.given("cos")) {
		typedef lemon::CostScaling<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
						 [](MCF &algo) -> typename MCF::ProblemType { return algo.run(); };
		solveGeneric<MCF>(fn);
	} else if (lmc.ap.given("ns")) {
		typedef lemon::NetworkSimplex<Digraph, Value> MCF;
		std::function<typename MCF::ProblemType(MCF &)> fn =
				      [](MCF &algo) -> typename MCF::ProblemType { return algo.run(); };
		solveGeneric<MCF>(fn);
	} else {
		std::cerr << "BUG: algorithm chosen unsupported." << std::endl;
		exit(1);
	}

	std::cerr << "ALGOTIME: " << ti << std::endl;
}

int main(int argc, const char *argv[]) {
	LemonMinCost lmc(argc, argv);
	lmc.run();

	return 0;
}
